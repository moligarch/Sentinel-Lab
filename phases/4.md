# Phase 4 (Milestone M14): Edge Sensors (eBPF/XDP & ETW)

This phase dives deep into high-performance event collection at the operating system level. The suggested order is to first learn the complex eBPF technology, make a key architectural decision, then build the Linux and enhance the Windows sensors, and finally, evaluate and harden both.

1.  `[Learn] eBPF and XDP Fundamentals` - Master the core Linux technology.
2.  `[Learn] eBPF User-space Library (Aya or cilium/ebpf)` - Learn the specific tools for the job.
3.  `[ADR] eBPF Language and Library Stack Selection` - Make a critical architectural decision.
4.  `[Build] net-sensors: Implement eBPF Kernel Program (XDP)` - Write the low-level packet processing code.
5.  `[Build] net-sensors: User-space Loader and Bus Publisher` - Write the high-level agent logic.
6.  `[Build] win-etw-agent: Implement Event Filtering and Shaping` - Enhance the existing Windows sensor.
7.  `[Eval] Benchmark Sensor Latency and Drop Rate Under Load` - Measure the performance of both sensors.
8.  `[Doc] Edge Sensor Security Hardening Checklist` - Create the production-readiness plan.

---
---

### 1. [Learn] eBPF and XDP Fundamentals

### Resource
*Learning eBPF* (by Liz Rice) and *BPF Performance Tools* (by Brendan Gregg).

### Phase
P4

### Module (if applicable)
net-sensors

### Goals / Why
To build a strong foundational understanding of eBPF. This is a complex but powerful technology. The goal is to understand the core concepts: the role of the in-kernel verifier, the different eBPF program types (XDP, kprobes, uprobes), and the mechanisms for communicating between kernel and user-space (maps, ring buffers).

### Notes / Summary
-   Diagram the eBPF development workflow: Write C/Rust -> Compile to eBPF bytecode -> Load into kernel -> Interact from user-space.
-   Summarize the limitations imposed by the eBPF verifier (e.g., no unbounded loops, bounded stack size).
-   Explain the difference between XDP and TC (Traffic Control) for packet processing.

### Definition of Done
- [ ] A summary of eBPF core concepts is committed to `/docs/learning/ebpf-fundamentals.md`.
- [ ] A simple "hello world" eBPF program (e.g., from a tutorial) is successfully compiled and loaded.
- [ ] Linked to milestone & project.

---

### 2. [Learn] eBPF User-space Library (Aya or cilium/ebpf)

### Resource
The Aya Book (for Rust) or the cilium/ebpf library documentation (for Go).

### Phase
P4

### Module (if applicable)
net-sensors

### Goals / Why
To learn the specific, high-level library that will be used to build the `net-sensors`. This moves from theory to practice. The goal is to understand the library's API for compiling, loading, and attaching eBPF programs, and for interacting with eBPF maps and ring buffers from a user-space application.

### Notes / Summary
-   Focus on the concept of CO-RE (Compile Once - Run Everywhere) and how the library supports it.
-   Create a small proof-of-concept that loads an eBPF program to count syscalls and reads the count from user-space.
-   Document the library's approach to handling eBPF map definitions and interactions.

### Definition of Done
- [ ] A small, runnable proof-of-concept project using the chosen library is committed.
- [ ] A cheat sheet of common API calls is created in `/docs/learning/ebpf-library-cheatsheet.md`.
- [ ] Linked to milestone & project.

---

### 3. [ADR] eBPF Language and Library Stack Selection

### Context
The `net-sensors` module requires a choice between two mature but different ecosystems for building eBPF applications: Rust with the Aya library or Go with the cilium/ebpf library. This decision impacts performance, memory safety guarantees, and the development workflow.

### Options
1.  **Rust + Aya**: Offers maximum performance and memory safety, but can have a steeper learning curve.
2.  **Go + cilium/ebpf**: Offers excellent developer ergonomics and a robust ecosystem, with garbage collection overhead to consider.

### Decision
Select one stack (e.g., "We will use Rust + Aya for the `net-sensors` module"). The rationale should be based on the project's primary goals, such as prioritizing raw performance and minimal memory footprint at the edge.

### Consequences
The chosen language and libraries will dictate the build toolchain, CI setup, and required skill set for maintaining the `net-sensors` module.

### File path"
`/docs/decisions/ADR-000X-ebpf-stack-selection.md`

### Follow-up Checklist
- [ ] Created doc file and linked this issue.
- [ ] Added owners/reviewers.

---

### 4. [Build] net-sensors: Implement eBPF Kernel Program (XDP)

### Module
net-sensors

### Phase
P4

### Design sketch / interfaces / contracts
-   Write an eBPF program using the chosen stack (e.g., in Rust using `aya-ebpf`).
-   The program will be of type XDP (eXpress Data Path) and will attach to a network interface.
-   **Logic**:
    -   Parse packet headers (Ethernet, IP, TCP/UDP).
    -   Extract the 5-tuple (source IP, dest IP, source port, dest port, protocol) to define a network flow.
    -   Use an eBPF hash map (`HashMap<Flow, FlowMetrics>`) to store counters (packet count, byte count) for each observed flow.

### Test Plan
-   The kernel program will be tested indirectly via the user-space loader.
-   Static analysis and verifier output will be the primary validation methods at this stage.

### Definition of Done
- [ ] The eBPF kernel program code is committed to the `net-sensors` module.
- [ ] The code successfully compiles into an eBPF object file (`.o`).
- [ ] A `README.md` explains the logic of the eBPF program.
- [ ] Linked to milestone & project.

---

### 5. [Build] net-sensors: User-space Loader and Bus Publisher

### Module
net-sensors

### Phase
P4

### Design sketch / interfaces / contracts
-   Write the user-space Rust/Go application for the `net-sensors` agent.
-   **Logic**:
    1.  Load the compiled eBPF object file into the kernel.
    2.  Attach the XDP program to a configurable network interface (e.g., `eth0`).
    3.  In a loop (e.g., every 10 seconds), iterate over the eBPF flow map.
    4.  Read the flow metrics, format them into the project's standard event schema, and publish them to the event bus.
    5.  Implement a backpressure strategy (e.g., dropping metric updates if the bus publisher is slow).

### Test Plan
-   Run the user-space agent in a test environment (e.g., a VM with `ping` or `iperf` running).
-   Verify that flow metrics are correctly published to the event bus and match the generated traffic.

### Definition of Done
- [ ] The user-space agent code is committed.
- [ ] The agent can be configured via a file or environment variables.
- [ ] The agent successfully publishes flow summaries to the event bus.
- [ ] Linked to milestone & project.

---

### 6. [Build] win-etw-agent: Implement Event Filtering and Shaping

### Module
win-etw-agent

### Phase
P4

### Design sketch / interfaces / contracts
-   Enhance the `win-etw-agent` skeleton from Phase 3.
-   Introduce a configuration file (`config.yaml`) that allows specifying filtering rules.
-   **Filtering Logic**: Implement server-side filtering to reduce data volume. For example, the config could specify:
    -   Only forward process creation events where `ProcessName == "powershell.exe"`.
    -   Drop all events from a list of noisy process names.
-   Bundle a WPA-recorded trace (`.etl`) file in the test assets to use for reproducible integration tests.

### Test Plan
-   Create an integration test that uses the bundled `.etl` file as an event source.
-   Run the test with different filter configurations and assert that only the correct, filtered events are produced by the agent.

### Definition of Done
- [ ] The agent supports filtering based on event properties.
- [ ] The filtering logic is covered by integration tests using a repro trace.
- [ ] The `README.md` is updated to document the new configuration options.
- [ ] Linked to milestone & project.

---

### 7. [Eval] Benchmark Sensor Latency and Drop Rate Under Load

### Area
Perf

### Metrics & targets
-   **`net-sensors`**: Maintain >99.9% event accuracy under 1 Gbps of network traffic.
-   **`win-etw-agent`**: Ingest 10k events/sec with <50ms p99 latency from event generation to bus publication.
-   **Goal**: Minimize kernel-to-user-space data copies.

### Plan
1.  **`net-sensors`**: Use a traffic generator like `iperf` or `pktgen` to create a high volume of network flows. Compare the metrics reported by the sensor to the ground truth from the generator to calculate accuracy/drop rate.
2.  **`win-etw-agent`**: Use a high-volume event generator on Windows (e.g., a script that rapidly creates/destroys processes). Measure the time difference between the ETW event's kernel timestamp and the time it is published to the bus.
3.  For both, monitor CPU and memory usage of the user-space agents.

### Definition of Done
- [ ] A performance report is created in `/docs/perf/M14-sensor-baseline.md`.
- [ ] The report includes graphs for latency, throughput, and resource utilization.
- [ ] Any identified bottlenecks are documented.

---

### 8. [Doc] Edge Sensor Security Hardening Checklist

### Phase
P4

### Summary
Create a comprehensive security review checklist for deploying and maintaining edge sensors (`net-sensors` and `win-etw-agent`). This document is a critical step towards production readiness.

### Where to put it
`/docs/security/sensor-hardening-checklist.md`

### Checklist / Extras
- [ ] **Capabilities**: Document the required OS capabilities (e.g., `CAP_BPF`, `CAP_PERFMON` for Linux; Administrator/System for Windows) and the principle of least privilege.
- [ ] **Kernel Pinning**: Define a strategy for pinning eBPF maps and programs to the filesystem to survive agent restarts.
- [ ] **Sandboxing**: Detail the seccomp profiles or other sandboxing mechanisms applied to the user-space agents.
- [ ] **Secure Updates**: Outline a plan for code-signing agent binaries and securely rolling out updates.