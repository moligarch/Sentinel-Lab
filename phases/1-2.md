# Phase 1 (Milestone M4): Systems & OS Foundations

Here is the suggested order for completing the tasks in Phase 1 to ensure foundational work and learning are done before building dependent components.

1.  `[ADR] Adopt MADR + docs structure` - Establishes project conventions first.
2.  `[Learn] OSTEP - Intro, Virtualization, and Concurrency` - Core OS theory.
3.  `[Learn] CS:APP caches & memory` - Core architecture theory.
4.  `[Learn] Rust ownership/borrowing quiz` - Language fundamentals for the first services.
5.  `[Learn] Linux perf/strace quick-ref` - Foundational tooling knowledge.
6.  `[Build] event-bus compose + pub/sub CLI + contract draft` - Infrastructure dependency.
7.  `[Build] rust-sensor-kit workspace` - First core component.
8.  `[Build] policy-orchestrator skeleton` - Second core component.
9.  `[Doc] E2E trace diagram` - Document the architecture once skeletons exist.
10. `[Doc] perf REPORT.md template + first baseline` - Create the report template and run the initial test.

---
---

### 1. [ADR] Adopt MADR + docs structure

* **Context**
    A long-running project needs a consistent way to record architectural decisions and a predictable documentation structure to ensure knowledge is discoverable.
* **Options**
    1. MADR (Markdown Architecture Decision Records)
    2. ADR-Tools
    3. ad-hoc Markdown
* **Decision**
    * Adopt the MADR template for all ADRs.
    * Store all decisions under `/docs/decisions/ADR-XXXX.md`.
    * Add the ADR templates to the repository's `.github` directory.
* **Consequences**
    This creates a small amount of upfront overhead for each decision but provides immense long-term value through searchable, reasoned records.
* **File path"**
    `/docs/decisions/ADR-0001.md`
* **Follow-up Checklist**
    - [ ] Created doc file and linked this issue
    - [ ] Added owners/reviewers

---

### 2. [Learn] OSTEP - Intro, Virtualization, and Concurrency

* **Resource**
    Operating Systems: Three Easy Pieces (Chapters 1-3, and related sections on Processes and Concurrency).
* **Phase**
    P1
* **Module (if applicable)**
    _No response_
* **Goals / Why**
    This project builds system-level software (sensors), so a deep understanding of the Operating System is non-negotiable. These initial chapters provide the mental model for everything that follows.
* **Notes / Summary**
    * **Introduction/Virtualization**: Understand the core job of the OS as a resource manager. Learn what a process is—the fundamental unit of execution—and how the OS creates the illusion that each process has its own private CPU and memory.
    * **Concurrency**: Learn about threads and the challenges they introduce, such as race conditions and the need for synchronization primitives like locks. This is the foundation for writing correct concurrent code in any language.
* **Definition of Done**
    - [ ] Commit summary notes for the covered chapters to `/docs/learning/ostep-intro-summary.md`. The notes should define a process, a thread, context switching, and scheduling in your own words.

---

### 3. [Learn] CS:APP caches & memory

* **Resource**
    CS:APP chapters on memory hierarchy & caching.
* **Phase**
    P1
* **Module (if applicable)**
    _No response_
* **Goals / Why**
    Understand cache lines, associativity, locality, and how they affect latency; apply to data structures, batching, and zero-copy strategies.
* **Notes / Summary**
    * Internalize cache hierarchy terms (L1, L2, L3) and the importance of data locality.
    * Study examples of "false sharing" and understand how to identify it using performance counters.
    * **Design Implication**: Always prefer contiguous memory (like vectors or arrays) for data on performance-critical hot paths.
* **Definition of Done**
    - [ ] Summary committed under `/docs/learning/csapp-caches-summary.md`.
    - [ ] Create a mini-lab with code examples demonstrating the performance difference between cache-friendly and cache-unfriendly memory access patterns.

---

### 4. [Learn] Rust ownership/borrowing quiz

* **Resource**
    The Rust Programming Language - Ownership & Borrowing chapters.
* **Phase**
    P1
* **Module (if applicable)**
    rust-sensor-kit
* **Goals / Why**
    To internalize Rust's move semantics and lifetimes. This is critical for writing efficient, safe code at the sensor boundary, avoiding hidden performance costs from unnecessary data clones and preventing undefined behavior.
* **Notes / Summary**
    Create a document with 5 tricky code examples related to ownership that you have solved, providing a clear explanation for each.
* **Definition of Done**
    - [ ] `docs/learning/rust-ownership-quiz.md` is created with the Q&A.
    - [ ] A unit test is added to a hot path in the `rust-sensor-kit` showing zero memory allocations.

---

### 5. [Learn] Linux perf/strace quick-ref

* **Resource**
    Man pages & kernel docs for `perf` and `strace`.
* **Phase**
    P1
* **Module (if applicable)**
    observability
* **Goals / Why**
    Create a practical, one-page reference for two of the most powerful Linux performance tools. This will be used for performance triage and analysis in later phases.
* **Notes / Summary**
    The document should include common commands for `strace` (tracing syscalls) and `perf` (sampling CPU, recording counters).
* **Definition of Done**
    - [ ] A reference page is created at `/docs/architecture/linux-perf-strace.md`.
    - [ ] An example capture file (e.g., the output of `perf record`) is committed under `/docs/perf/` for future reference.

---

### 6. [Build] event-bus compose + pub/sub CLI + contract draft

* **Module**
    event-bus
* **Phase**
    P1
* **Design sketch / interfaces / contracts**
    * Create a Docker compose file for running NATS locally.
    * Define the subject/topic naming strategy for different kinds of events.
    * Draft the initial event schema and define a versioning policy (e.g., using JSON-Schema or Protobuf) in the `/contracts` directory.
* **Test Plan**
    * Create a tiny command-line interface (CLI) for testing, e.g., `pubsub publish <file.json>` and `pubsub subscribe <subject>`.
    * Run an end-to-end test using the CLI to publish an event from a file and verify it's received by a subscriber.
* **Definition of Done**
    - [ ] README updated with CLI usage.
    - [ ] Contract doc saved in `/contracts/`.
    - [ ] Baseline latency for a round-trip message is recorded.

---

### 7. [Build] rust-sensor-kit workspace

* **Module**
    rust-sensor-kit
* **Phase**
    P1
* **Design sketch / interfaces / contracts**
    * Set up a Cargo workspace with a logical layout: `core/` (types), `inputs/` (proc, file), `outputs/` (bus).
    * Define a central `EventSource` trait for inputs and an `EventSink` trait for outputs.
    * Design an event struct that aims for zero-copy data handling.
    * Use Cargo feature flags to allow compiling with mock sources/sinks for testing vs. real ones.
* **Test Plan**
    * Use property-based testing for the event schema to ensure robustness.
    * (Optional) Check if the core library can be built in a `no-std` environment.
* **Definition of Done**
    - [ ] README updated with workspace structure and feature flags documented.
    - [ ] Perf baseline for creating and serializing an event is recorded.
    - [ ] Linked to milestone & project.

---

### 8. [Build] policy-orchestrator skeleton

* **Module**
    policy-orchestrator
* **Phase**
    P1
* **Design sketch / interfaces / contracts**
    * Create an Axum web service with essential, observable endpoints: `GET /healthz`, `GET /metrics`.
    * Implement the primary data ingress endpoint: `POST /ingest` which accepts a payload conforming to `/contracts/event.json`.
    * Handle configuration via environment variables.
    * **Backpressure Strategy**: Ingested events are sent to a bounded channel. If full, apply a "drop" policy and emit a metric.
* **Test Plan**
    * Unit tests for request validation logic.
    * Integration tests for the `/ingest` endpoint covering both successful and error paths.
    * A baseline load test at 1k requests per second (rps) to record initial p50/p99 latency.
* **Definition of Done**
    - [ ] README updated with API endpoints and config options.
    - [ ] Perf baseline from the 1k rps test is added to `/docs/perf/REPORT.md`.
    - [ ] Linked to milestone & project.

---

### 9. [Doc] E2E trace diagram

* **Phase**
    P1
* **Summary**
    Create a system architecture diagram using Mermaid. The diagram should visualize the end-to-end flow of an event and its associated trace context. It must show: `sensor` → `bus` → `orchestrator` and the propagation of a `trace_id`.
* **Where to put it**
    `/docs/architecture/overview.md`
* **Checklist / Extras**
    - [ ] Added diagram to the markdown file.
    - [ ] Linked to relevant OTel documentation for context propagation.

---

### 10. [Doc] perf REPORT.md template + first baseline

* **Phase**
    P1
* **Summary**
    Create a standardized template for all future performance reports. Use this new template to document the 1k rps baseline test of the `policy-orchestrator`.
* **Where to put it**
    `/docs/perf/REPORT.md`
* **Checklist / Extras**
    - [ ] Template includes sections for Environment, Methodology, Scenarios, Metrics, and Conclusions.
    - [ ] Baseline orchestrator test results are filled in.
    - [ ] Added screenshots/flamegraphs from the baseline test.

---
---

# Phase 2 (Milestone M8): Concurrency & Perf (Go/Rust)

Here is the suggested order for completing the tasks in Phase 2. The focus is on learning the Go ecosystem, then building and hardening the high-performance `enrichment-services`, and finally evaluating them.

1.  `[Learn] Go Memory Model notes + examples` - Core language theory for concurrency.
2.  `[Learn] pprof/runtime/trace runbook` - Practical performance tooling for Go.
3.  `[Learn] Systems Performance notes` - Broader systems performance methodology.
4.  `[Build] enrichment-services resilience` - The main build task of the phase.
5.  `[Build] Observability: OTel traces across Rust↔Go + Grafana p50/p99` - Depends on services being built.
6.  `[Build] Test automation workflow` - Ensures quality for all new and existing code.
7.  `[Eval] Load test 10–50k rps path` - The final evaluation of the phase's build work.

---
---

### 1. [Learn] Go Memory Model notes + examples

* **Resource**
    Go Memory Model official documentation and Effective Go's concurrency section.
* **Phase**
    P2
* **Module (if applicable)**
    enrichment-services
* **Goals / Why**
    To deeply understand the guarantees the Go runtime provides for concurrent operations. This is essential to prevent subtle data races and write correct, high-performance concurrent code in the `enrichment-services`.
* **Notes / Summary**
    Create mini-examples demonstrating common concurrency patterns, including code with and without `sync/atomic` to show happens-before relationships, and correct use of channel patterns.
* **Definition of Done**
    - [ ] Notes are committed to `/docs/learning/go-memory-model.md`.
    - [ ] Runnable examples are committed to the repository.
    - [ ] Linked to milestone & project.

---

### 2. [Learn] pprof/runtime/trace runbook

* **Resource**
    Go `pprof` & `runtime/trace` guides.
* **Phase**
    P2
* **Module (if applicable)**
    observability
* **Goals / Why**
    To develop a repeatable, documented method for capturing and analyzing performance data from Go services. This runbook will be the standard procedure for any performance investigation.
* **Notes / Summary**
    The runbook should detail commands to capture CPU/heap profiles, how to interpret flamegraphs, and tips for using `runtime/trace` to find GC pauses or scheduler latency.
* **Definition of Done**
    - [ ] The runbook is created at `/docs/perf/go-pprof-runbook.md`.
    - [ ] Sample profiles captured from a Go service are added to the repository.
    - [ ] Linked to milestone & project.

---

### 3. [Learn] Systems Performance notes

* **Resource**
    *Systems Performance* (by Brendan Gregg) – focus on CPU and disk chapters.
* **Phase**
    P2
* **Module (if applicable)**
    observability
* **Goals / Why**
    To learn a systematic methodology for performance triage. Understand which system counters are important, how to read flamegraphs correctly, and how to form hypotheses about bottlenecks.
* **Notes / Summary**
    Summarize key concepts and methodologies from the book.
* **Definition of Done**
    - [ ] Key takeaways are committed to `/docs/learning/systems-performance-notes.md`.
    - [ ] Linked to milestone & project.

---

### 4. [Build] enrichment-services resilience

* **Module**
    enrichment-services
* **Phase**
    P2
* **Design sketch / interfaces / contracts**
    * Implement a suite of resilience patterns for all external clients (gRPC/HTTP).
    * **Retries**: Use exponential backoff with jitter.
    * **Timeouts/Deadlines**: Enforce strict deadlines on all outbound requests.
    * **Bulkheads**: Limit concurrent requests to any single dependency.
    * **Circuit Breakers**: Automatically stop sending requests to a failing dependency.
* **Test Plan**
    * Inject faults into mock dependencies to verify that retries and circuit breakers are triggered correctly.
    * Run chaos tests (e.g., killing a dependency) to measure the service's resilience.
* **Definition of Done**
    - [ ] README updated with resilience strategies and configuration.
    - [ ] Perf baseline under failure conditions is recorded.
    - [ ] SLOs & alerts for circuit breaker state are configured.
    - [ ] Linked to milestone & project.

---

### 5. [Build] Observability: OTel traces across Rust↔Go + Grafana p50/p99

* **Module**
    observability
* **Phase**
    P2
* **Design sketch / interfaces / contracts**
    * Implement OpenTelemetry (OTel) in both Rust and Go services to achieve end-to-end distributed tracing.
    * Ensure trace context is propagated correctly across the message bus.
    * Establish consistent trace and metric attributes.
    * Build Grafana dashboards for key SLOs: p50/p99 latency, throughput, and error ratios.
* **Test Plan**
    * Generate synthetic traffic and verify that complete, linked traces appear in the backend.
    * Confirm that the Grafana dashboards update correctly with data from both services.
* **Definition of Done**
    - [ ] README updated in the `/observability` module.
    - [ ] Dashboards are saved as JSON in the repository.
    - [ ] An alert for a key SLO (e.g., p99 latency > 200ms) is configured.
    - [ ] Linked to milestone & project.

---

### 6. [Build] Test automation workflow

* **Module**
    policy-orchestrator
* **Phase**
    P2
* **Design sketch / interfaces / contracts**
    * Set up a GitHub Actions workflow that triggers on every pull request.
    * The workflow must run formatters, linters, and tests for all Rust and Go code.
    * A PR should be blocked from merging if any of these steps fail.
* **Test Plan**
    * Create a test PR that intentionally fails a linter check to ensure the workflow blocks it.
    * Create a test PR that passes all checks to ensure it can be merged.
* **Definition of Done**
    - [ ] The workflow YAML file is committed to `.github/workflows/`.
    - [ ] The repository settings are updated to require this check to pass before merging.
    - [ ] Linked to milestone & project.

---

### 7. [Eval] Load test 10–50k rps path

* **Area**
    Perf
* **Metrics & targets**
    * Define specific p50/p99 latency targets for the enrichment path.
    * Ensure zero data loss during the test.
    * Monitor and stay within defined CPU and memory budgets.
* **Plan**
    * Write a test scenario using `k6` or `vegeta`.
    * During the test run, record flamegraphs from the services under load.
    * Compare the performance deltas against the baseline established in Phase 1.
* **Definition of Done**
    - [ ] Results are stored under `/eval-harness/results/`.
    - [ ] The load test is integrated into a CI pipeline to run nightly or on-change.
    - [ ] A link to the updated performance report is added to this issue.