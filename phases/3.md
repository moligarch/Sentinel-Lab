# Phase 3 (Milestone M11): Rhai Rules Engine v1 (+ ETW intro)

Here is the suggested order for completing the tasks in Phase 3. The plan prioritizes learning the necessary technologies, then building the core rule engine, adding advanced features and security, building the initial Windows agent, and finally, creating the rules and tests to validate the entire system.

1.  `[Learn] Domain-Specific Languages (DSL) Design` - Understand the "why" before the "how".
2.  `[Learn] The Rhai Scripting Language & Rust Integration` - Master the core technology.
3.  `[Learn] Windows Internals & ETW Fundamentals` - Foundational knowledge for the Windows sensor.
4.  `[Build] rule-engine: Initial Service Skeleton` - Create the container for the engine logic.
5.  `[Build] rule-engine: Embed Rhai and Define Scripting API` - Implement the core functionality.
6.  `[Build] rule-engine: AST Caching and Hot-Reloading` - Add performance and operational features.
7.  `[Build] rule-engine: Sandboxing and Resource Limiting` - Implement critical security constraints.
8.  `[Build] win-etw-agent: Skeleton ETW Consumer` - A proof-of-concept for Windows event ingestion.
9.  `[Build] rule-engine: Create Sample Rules Pack (ATT&CK Mapped)` - Develop content to prove the engine works.
10. `[Eval] rule-engine: Golden Testkit and Fuzz Testing` - Validate correctness and security.

---
---

### 1. [Learn] Domain-Specific Languages (DSL) Design

### Resource
*Domain-Specific Languages* (by Martin Fowler)

### Phase
P3

### Module (if applicable)
rule-engine

### Goals / Why
To understand the patterns, trade-offs, and design principles behind creating an effective DSL. This will inform how the Rhai scripts are structured, what functions the Rust host should expose, and how to create a rule language that is both powerful for developers and understandable for security analysts.

### Notes / Summary
-   Focus on the differences between internal and external DSLs.
-   Summarize key patterns like "Semantic Model" and "Expression Builder".
-   Analyze how these patterns apply to defining security detection rules.

### Definition of Done
- [ ] Summary of key DSL patterns committed to `/docs/learning/dsl-design-notes.md`.
- [ ] A small prototype of a "Rule" struct in Rust that represents the semantic model is created.
- [ ] Linked to milestone & project.

---

### 2. [Learn] The Rhai Scripting Language & Rust Integration

### Resource
*The Rhai Book* (official documentation)

### Phase
P3

### Module (if applicable)
rule-engine

### Goals / Why
To gain mastery of the Rhai scripting language and its integration with Rust. This is the core technology for the rule engine. Key areas of focus are function registration, passing complex Rust types into the script scope, error handling, and sandboxing capabilities.

### Notes / Summary
-   Practice writing simple Rhai scripts.
-   Create a small Rust application that embeds the Rhai engine, registers a custom Rust function, and calls it from a script.
-   Document the process for limiting script capabilities (e.g., disabling access to the filesystem or network).

### Definition of Done
- [ ] A `rhai-cheatsheet.md` is committed to `/docs/learning/`.
- [ ] A small, runnable "proof-of-concept" project is committed to a learning directory.
- [ ] Linked to milestone & project.

---

### 3. [Learn] Windows Internals & ETW Fundamentals

### Resource
*Windows Internals, Part 1 (7e)* and Microsoft's official ETW documentation.

### Phase
P3

### Module (if applicable)
win-etw-agent

### Goals / Why
To build a foundational understanding of the Event Tracing for Windows (ETW) architecture. This is necessary to build an efficient and correct `win-etw-agent`. The goal is to understand providers, consumers, sessions, and the basics of the WPA/WPR toolchain for diagnostics.

### Notes / Summary
-   Define: Kernel vs. User-mode ETW providers.
-   Diagram the relationship between a provider, a session, and a consumer.
-   Summarize the steps to start a trace session and consume events from a specific provider (e.g., `Microsoft-Windows-Kernel-Process`).

### Definition of Done
- [ ] A summary of the ETW architecture is committed to `/docs/learning/etw-fundamentals.md`.
- [ ] Use `logman` or `wpr` to capture a small trace file (`.etl`) of process creation events.
- [ ] Linked to milestone & project.

---

### 4. [Build] rule-engine: Initial Service Skeleton

### Module
rule-engine

### Phase
P3

### Design sketch / interfaces / contracts
-   Create a new Rust binary service named `rule-engine`.
-   The service will connect to the event bus and subscribe to the main event topic.
-   Implement basic OpenTelemetry stubs for tracing and metrics.
-   Structure the project with modules for `engine`, `rules`, and `testing`.

### Test Plan
-   An integration test will publish a mock event to the bus and assert that the `rule-engine` service logs its reception.

### Definition of Done
- [ ] The service skeleton is created in the `/services` directory.
- [ ] The service successfully consumes events from the bus in a local `docker-compose` environment.
- [ ] Linked to milestone & project.

---

### 5. [Build] rule-engine: Embed Rhai and Define Scripting API

### Module
rule-engine

### Phase
P3

### Design sketch / interfaces / contracts
-   Integrate the `rhai` crate into the `rule-engine` service.
-   On receiving an event, the service will load a placeholder Rhai script from a file.
-   **API Surface**: Define and register a set of Rust functions that will be callable from within Rhai scripts. This includes:
    -   `emit(detection_event)`: To signal a match.
    -   `enrich(field, source)`: A placeholder for future enrichment calls.
    -   A set of matcher functions (e.g., `process.path.ends_with(...)`).
-   An event from the bus will be deserialized into a Rust struct and passed into the Rhai script's scope.

### Test Plan
-   Unit test each registered Rust function.
-   Write a simple Rhai script that uses the API and run it in a test to verify it executes correctly and can access event data.

### Definition of Done
- [ ] The `rule-engine` can execute a `.rhai` script for each event it receives.
- [ ] The core API functions are accessible from the script.
- [ ] Linked to milestone & project.

---

### 6. [Build] rule-engine: AST Caching and Hot-Reloading

### Module
rule-engine

### Phase
P3

### Design sketch / interfaces / contracts
-   The service will monitor a `rules/` directory for any file changes (create, modify, delete).
-   When a rule file is added or modified, the service will pre-compile it into an Abstract Syntax Tree (AST) using `engine.compile()`.
-   The compiled AST will be stored in an in-memory, thread-safe cache (e.g., using `DashMap<PathBuf, Arc<AST>>`).
-   When an event is processed, the engine will retrieve the cached AST for the relevant rule(s) and execute it, avoiding re-parsing the script text.

### Test Plan
-   Write a test that starts the service, modifies a rule file on disk, and verifies that the cache is updated.
-   Benchmark the performance difference between executing a raw script string vs. a pre-compiled, cached AST.

### Definition of Done
- [ ] Rules can be added or changed at runtime without restarting the `rule-engine` service.
- [ ] A performance report is created showing the latency improvement from AST caching.
- [ ] Linked to milestone & project.

---

### 7. [Build] rule-engine: Sandboxing and Resource Limiting

### Module
rule-engine

### Phase
P3

### Design sketch / interfaces / contracts
-   Configure every Rhai `Engine` instance with strict resource limits to ensure rule execution is safe.
-   **Resource Limits**:
    -   Set a maximum number of operations per script run to prevent infinite loops (`engine.set_max_operations()`).
    -   Limit the maximum call stack depth.
-   **Sandboxing**:
    -   Disable language features that could interact with the host system, such as the `eval` function or file I/O.
    -   Ensure the API exposed to scripts does not allow for arbitrary command execution or memory access.

### Test Plan
-   Write specific test rules that attempt to violate the limits (e.g., an infinite loop) and assert that they fail with the expected error.
-   Write a test to prove that a script cannot call an unregistered or disabled function.

### Definition of Done
- [ ] All security configurations are applied to the Rhai engine.
- [ ] Tests are in place to prove that the sandboxing and resource limits are effective.
- [ ] Linked to milestone & project.

---

### 8. [Build] win-etw-agent: Skeleton ETW Consumer

### Module
win-etw-agent

### Phase
P3

### Design sketch / interfaces / contracts
-   Create a new Rust binary service named `win-etw-agent`.
-   Use a crate like `krabsetw` or `ferris-etw` to create a basic ETW consumer.
-   The agent will subscribe to one or two well-known kernel providers, such as `Microsoft-Windows-Kernel-Process` for process creation events.
-   Received ETW events will be transformed into the project's standard event schema (from `/contracts`) and published to the event bus.

### Test Plan
-   Run the agent on a Windows machine.
-   Start a new process (e.g., `notepad.exe`).
-   Verify that a corresponding process creation event appears on the event bus, as confirmed by a `pubsub subscribe` client.

### Definition of Done
- [ ] The agent is created in the `/services` directory.
- [ ] The agent successfully forwards process creation events to the bus.
- [ ] A `README.md` documents how to build and run the agent.
- [ ] Linked to milestone & project.

---

### 9. [Build] rule-engine: Create Sample Rules Pack (ATT&CK Mapped)

### Module
rule-engine

### Phase
P3

### Design sketch / interfaces / contracts
-   Create a `rules/` directory within the `rule-engine` service.
-   Write a set of at least 3-5 sample detection rules as `.rhai` script files.
-   **Rule Examples**:
    1.  Detect a suspicious process spawn (e.g., `powershell.exe` with an encoded command).
    2.  Detect a suspicious DNS query to a known malicious domain.
    3.  Detect a sensitive file being written to by an unexpected process.
-   In the comments of each rule file, map the detection logic to one or more MITRE ATT&CK techniques.

### Test Plan
-   The rules will be tested as part of the "Golden Testkit" task. Each rule must have corresponding "pass" and "fail" test cases.

### Definition of Done
- [ ] The sample `.rhai` files are committed to the repository.
- [ ] Each rule includes comments with its name, description, and ATT&CK mapping.
- [ ] Linked to milestone & project.

---

### 10. [Eval] rule-engine: Golden Testkit and Fuzz Testing

### Area
Perf

### Metrics & targets
-   Golden tests: 100% pass rate for the sample rules pack.
-   Fuzzing: No panics or memory safety issues discovered after 1 million iterations.

### Plan
-   **Golden Testkit**:
    1.  Create a directory of test cases, where each case is an input event (`.json`) and an expected output detection (`.json`).
    2.  Create a test harness in Rust that iterates through all test cases, runs the corresponding rule against the input, and asserts that the output matches the expected "golden" file.
-   **Fuzz Testing**:
    1.  Set up `cargo-fuzz` to target the function that takes a string and parses/compiles it into a Rhai AST.
    2.  Run the fuzzer for a significant number of iterations to find panics or other crashes in the parsing logic.

### Definition of Done
- [ ] The golden testkit is integrated into the CI pipeline.
- [ ] A fuzzing target is created and documented in the `rule-engine` README.
- [ ] A report summarizing the fuzzing run and any findings is created.